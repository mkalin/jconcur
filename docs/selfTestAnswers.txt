Here are some answers (or sketches of answers) from the self-test questions/exercises.

# Class 1 Morning

From basicC.BasicCounter.java:

## Answer

1. The java.lang.Thread class implements the java.lang.Runnable interface, which
   declares a single method: public void run().

   It's thus a matter of convenience and taste about whether to have a class
   such as BasicCounter extend Thread or implement Runnable. In this example, either
   approach works the same, assuming that the override of run() is the same.

2. The java.lang.Thread class provides an empty implementation of run(), thereby
   exhibiting what's called the 'adapter pattern'. In effect, the java.lang.Thread
   implementation is:

      // java.lang.Thread override
      public void run() { }   // empty body, hence a no-op

   If you extend Thread but fail to override run(), you wind up with this empty
   implementation -- and recall that any thread terminates when the thread exits
   the run() method.

-----

# Class 1 Afternoon

From review.AtomicCounter.java:

1. In the current implementation, the three methods that can access the instance field
   named 'c' are synchronized on 'this', an instance of a SynchronizedCounter. The
   implementation makes sense in that there is one counter field per SynchronizedCounter
   instance: each counter keeps its own count.

   If the field named 'c' were made static, then there'd be one such field across _all_
   SynchronizedCounter instances; but two different instances then could provoke a
   race condition because the locks would differ:

       SynchronizedCounter sc1 = new SynchronizedCounter(); // lock is sc1
       SynchronizedCounter sc2 = new SynchronizedCounter(); // lock is sc2
       ...                 // Assume thread t1 has access to sc1, and thread t2 has access to sc2

       //## race condition
       sc1.increment();    // Invoked in thread t1 -- there's no shared lock with sc2
       
       sc2.increment();    // Invoked in thread t2 -- there's no shared lock with sc1

   Finally, it's hard to see the usefulness of a single counter field shared across multiple
   SynchronizedCounter instances. If exactly one SynchronizedCounter is needed in some app, then
   implementing the 'singleton pattern' seems the cleaner way to go.
-----

# Class 2 Morning

From bq.AccountBQ

System.out is of type java.io.PrintStream, and the JavaDoc confirms that none of the
'print' methods in PrintStream is synchronized. In this technical sense, System.out.println(...)
is _not_ thread-safe. 

However, a typical JVM implementation will make println thread-safe. Here, for example, is the published OpenJDK 
implementation for println:

   public void println(String x) { //## ditto for other overrloads
       synchronized (this) {       //## 'this' refers to _one_ PrintStream instance, here the 'standard output'
           print(x);
           newLine();
       }
   }

See http://hg.openjdk.java.net/jdk6/jdk6/jdk/file/39e8fe7a0af1/src/share/classes/java/io/PrintStream.java for
more details.

A thread-safe System.out.println(...) is not guaranteed at the API level, but highly likely in any JVM
implementation.
-----
