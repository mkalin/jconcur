The java.util.concurrent package includes a number of additions to the Java Collections Framework. 
These are most easily categorized by the collection interfaces provided:

-- java.util.concurrent interfaces

These types are meant to help the programmer resort to explicit synchronization, although the documentation
must be read carefully: in some cases, data races still can occur if the programmer uses incorrect methods

In the strict sense, these types promote rather than guarantee thread safety.

BlockingQueue: interface for FIFO (first-in, first-out) structures that block on 'add' operations to a full queue and
               'remove' operations from an empty queue. A SynchronousQueue (see example...) is one
               implementation. 

ConcurrentMap: is a subinterface of java.util.Map that defines useful atomic operations. These operations remove or replace 
               a key-value pair only if the key is present, or add a key-value pair only if the key is absent. 

Making these operations atomic helps avoid synchronization. The standard general-purpose implementation of ConcurrentMap is ConcurrentHashMap, 
which is a concurrent analog of HashMap.

ConcurrentNavigableMap is a subinterface of ConcurrentMap that supports approximate matches. The standard general-purpose 
implementation of ConcurrentNavigableMap is ConcurrentSkipListMap, which is a concurrent analog of TreeMap.

All of these collections help avoid Memory Consistency Errors by defining a happens-before relationship between an 
operation that adds an object to the collection with subsequent operations that access or remove that object.

